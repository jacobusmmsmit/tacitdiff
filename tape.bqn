ast â† â€¢Import "ast.bqn"
âŸ¨T, dâŸ© â† â€¢Import "chainrules.bqn"


# Construct a Wengert list (new class) from a function as an object of class Wengert list
# Traverse it forwards for primal pass as a method of Wengert list
# Traverse it backwards for backward pass as a method of Wengert list
# The Wengert list methods are
# 1. init: convert the given tacit block into a forward Wengert list and its dual, store as properties
# 2. forward: evaluate the forward list at the input
# 3. backward: evaluate the backward list in reverse

# Test whether a decomposed tacit expression needs to be decomposed further
Final â† {1=â‰ ğ•© ? 1 ; Â¬1<âŒˆÂ´â‰ Â¨ğ•©}

# Take an AST and return a Wengert list (tape) where the names of intermediate
# variables are relative to their distance from the instruction in question.
RWL â† {
  ğ•Š a: 1 ğ•Š a;
  c ğ•Š a: Rec â† ğ•Š
  {
    1: { # If final
      {
        âŸ¨2,f,gâŸ©:   âŸ¨âŸ¨1, GâŸ©, âŸ¨c, FâŸ©âŸ©;
        âŸ¨3,f,b,gâŸ©: âŸ¨âŸ¨1, câŸ©, F B GâŸ©;
        âŸ¨4,f,râŸ©:   âŸ¨âŸ¨c, F _râŸ©âŸ©;
        âŸ¨5,f,r,gâŸ©: âŸ¨âŸ¨c, F _r_ GâŸ©âŸ©;
        âŸ¨âŸ¨âŸ¨1, câŸ©,aâŸ©âŸ©
      } a
    };
    0: { # If not final
      âŸ¨2,f,gâŸ©: Rec g, Rec f;
      âŸ¨3,f,b,gâŸ©: {
        iâ†Rec g
        jâ†(1+â‰ i) Rec f
        kâ†(1+â‰ j) Rec b
        iâˆ¾jâˆ¾k
      };
      âŸ¨4,f,uâŸ©: "You hit a 4, good luck";
      âŸ¨5,f,r,gâŸ©: { # Partially applied dyads
        iâ†Rec g
        jâ†(1+â‰ i)Rec f
        kâ†(1+â‰ j)Rec r
        iâˆ¾jâˆ¾k
      }
    } a
  } Final a
}

# Turn a relative Wengert list into an (absolute) Wengert list
AWL â† (â†•âˆ˜â‰ -âŠ¢)âŒ¾(âŠ‘Â¨)

# Differentiate an entry in an AWL or RWL
Diff â† {
  ğ•Š f: 2;
  args ğ•Š f: 3
}

F â† (2âŠ¸+) + (2âŠ¸+)
tr â† AST âŠ‘âŸ¨fâŸ©
list â† AWL RWL tr
lâ† âŸ¨âŸ¨1, 2âŸ©, âŸ¨1, 0âŸ©, âŸ¨1, 3âŸ©, 2â€¿2, 2â€¿2, 3â€¿3âŸ©

# Evaluate a given Wengert list ğ•¨ at an argument ğ•©
Eval â† {
  xğ•Ša: # Pop and match on tail instruction pair: âŸ¨argument pointer(s), operationâŸ©
  {
    # Base case: match on (number of) argument pointers
    âŸ¨Â¯1, fâŸ©: F a;
    âŸ¨âŸ¨Â¯1, Â¯1âŸ©, fâŸ©: FÂ´âŸ¨a, aâŸ©;
    # Recursive case: new instruction list goes up to where the last one points to
    âŸ¨ap, opâŸ©: x_rest â† ({ğ•©âŠx}(â†•1âŠ¸+))Â¨ap # Note that Self isn't needed with Before (âŠ¸) and After (âŸœ), which essentially have a copy built in: for example FâŠ¸G ğ•© is the same as FâŠ¸GËœ ğ•© by definition.
    {
      âŸ¨ap1, ap2âŸ©: ((âŠ‘x_rest) Eval a) Op ((Â¯1âŠ‘x_rest) Eval a);
      ğ•©: x_rest Eval a
    } ap
  }Â¯1âŠ‘x
}

â€¢Show list
â€¢Show list Eval 3
â€¢Show RWL tr
RWL AST âŠ‘âŸ¨âŠ¢+âŠ¢âŸ©


# Problems:
# - If the function doesn't emit a vector of instructions, its relative Wengert list
#   is a single instruction not a list of instructions and so AWL wengert_list won't work
# - Some functions aren't work with RWL properly